import { getCurrentScope, computed, reactive, watch, onScopeDispose, toRefs, readonly, unref } from 'vue-demi';
import { useQueryClient } from './useQueryClient.esm.js';
import { updateState, shouldThrowError, isQueryKey, cloneDeepUnref } from './utils.esm.js';

function useBaseQuery(Observer, arg1, arg2 = {}, arg3 = {}) {
  var _options$value$queryC;

  if (process.env.NODE_ENV === 'development') {
    if (!getCurrentScope()) {
      console.warn('vue-query composables like "useQuery()" should only be used inside a "setup()" function or a running effect scope. They might otherwise lead to memory leaks.');
    }
  }

  const options = computed(() => parseQueryArgs(arg1, arg2, arg3));
  const queryClient = (_options$value$queryC = options.value.queryClient) != null ? _options$value$queryC : useQueryClient(options.value.queryClientKey);
  const defaultedOptions = computed(() => {
    const defaulted = queryClient.defaultQueryOptions(options.value);
    defaulted._optimisticResults = queryClient.isRestoring.value ? 'isRestoring' : 'optimistic';
    return defaulted;
  });
  const observer = new Observer(queryClient, defaultedOptions.value);
  const state = reactive(observer.getCurrentResult());

  let unsubscribe = () => {// noop
  };

  watch(queryClient.isRestoring, isRestoring => {
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    if (!isRestoring) {
      unsubscribe();
      unsubscribe = observer.subscribe(result => {
        updateState(state, result);
      });
    }
  }, {
    immediate: true
  });

  const updater = () => {
    observer.setOptions(defaultedOptions.value);
    updateState(state, observer.getCurrentResult());
  };

  watch(defaultedOptions, updater);
  onScopeDispose(() => {
    unsubscribe();
  }); // fix #5910

  const refetch = (...args) => {
    updater();
    return state.refetch(...args);
  };

  const suspense = () => {
    return new Promise((resolve, reject) => {
      let stopWatch = () => {//noop
      };

      const run = () => {
        if (defaultedOptions.value.enabled !== false) {
          const optimisticResult = observer.getOptimisticResult(defaultedOptions.value);

          if (optimisticResult.isStale) {
            stopWatch();
            observer.fetchOptimistic(defaultedOptions.value).then(resolve, reject);
          } else {
            stopWatch();
            resolve(optimisticResult);
          }
        }
      };

      run();
      stopWatch = watch(defaultedOptions, run);
    });
  }; // Handle error boundary


  watch(() => state.error, error => {
    if (state.isError && !state.isFetching && shouldThrowError(defaultedOptions.value.useErrorBoundary, [error, observer.getCurrentQuery()])) {
      throw error;
    }
  });
  const object = toRefs(readonly(state));

  for (const key in state) {
    if (typeof state[key] === 'function') {
      object[key] = state[key];
    }
  }

  object.suspense = suspense;
  object.refetch = refetch;
  return object;
}
function parseQueryArgs(arg1, arg2 = {}, arg3 = {}) {
  const plainArg1 = unref(arg1);
  const plainArg2 = unref(arg2);
  const plainArg3 = unref(arg3);
  let options = plainArg1;

  if (!isQueryKey(plainArg1)) {
    options = plainArg1;
  } else if (typeof plainArg2 === 'function') {
    options = { ...plainArg3,
      queryKey: plainArg1,
      queryFn: plainArg2
    };
  } else {
    options = { ...plainArg2,
      queryKey: plainArg1
    };
  }

  const clondedOptions = cloneDeepUnref(options);

  if (typeof clondedOptions.enabled === 'function') {
    clondedOptions.enabled = clondedOptions.enabled();
  }

  return clondedOptions;
}

export { parseQueryArgs, useBaseQuery };
//# sourceMappingURL=useBaseQuery.esm.js.map
