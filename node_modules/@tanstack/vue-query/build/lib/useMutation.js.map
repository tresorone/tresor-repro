{"version":3,"file":"useMutation.js","sources":["../../src/useMutation.ts"],"sourcesContent":["import {\n  computed,\n  getCurrentScope,\n  onScopeDispose,\n  reactive,\n  readonly,\n  toRefs,\n  unref,\n  watch,\n} from 'vue-demi'\nimport { MutationObserver } from '@tanstack/query-core'\nimport {\n  cloneDeepUnref,\n  isMutationKey,\n  shouldThrowError,\n  updateState,\n} from './utils'\nimport { useQueryClient } from './useQueryClient'\nimport type { ToRefs } from 'vue-demi'\nimport type {\n  MutateFunction,\n  MutateOptions,\n  MutationFunction,\n  MutationKey,\n  MutationObserverOptions,\n  MutationObserverResult,\n} from '@tanstack/query-core'\nimport type {\n  DistributiveOmit,\n  MaybeRef,\n  MaybeRefDeep,\n  WithQueryClientKey,\n} from './types'\n\ntype MutationResult<TData, TError, TVariables, TContext> = DistributiveOmit<\n  MutationObserverResult<TData, TError, TVariables, TContext>,\n  'mutate' | 'reset'\n>\n\nexport type UseMutationOptions<TData, TError, TVariables, TContext> =\n  WithQueryClientKey<\n    MutationObserverOptions<TData, TError, TVariables, TContext>\n  >\n\nexport type VueMutationObserverOptions<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> = {\n  [Property in keyof UseMutationOptions<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  >]: MaybeRefDeep<\n    UseMutationOptions<TData, TError, TVariables, TContext>[Property]\n  >\n}\n\ntype MutateSyncFunction<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> = (\n  ...options: Parameters<MutateFunction<TData, TError, TVariables, TContext>>\n) => void\n\nexport type UseMutationReturnType<\n  TData,\n  TError,\n  TVariables,\n  TContext,\n  Result = MutationResult<TData, TError, TVariables, TContext>,\n> = ToRefs<Readonly<Result>> & {\n  mutate: MutateSyncFunction<TData, TError, TVariables, TContext>\n  mutateAsync: MutateFunction<TData, TError, TVariables, TContext>\n  reset: MutationObserverResult<TData, TError, TVariables, TContext>['reset']\n}\n\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  options: MaybeRef<\n    VueMutationObserverOptions<TData, TError, TVariables, TContext>\n  >,\n): UseMutationReturnType<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationFn: MaybeRef<MutationFunction<TData, TVariables>>,\n  options?: MaybeRef<\n    Omit<\n      VueMutationObserverOptions<TData, TError, TVariables, TContext>,\n      'mutationFn'\n    >\n  >,\n): UseMutationReturnType<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MaybeRef<MutationKey>,\n  options?: MaybeRef<\n    Omit<\n      VueMutationObserverOptions<TData, TError, TVariables, TContext>,\n      'mutationKey'\n    >\n  >,\n): UseMutationReturnType<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MaybeRef<MutationKey>,\n  mutationFn?: MaybeRef<MutationFunction<TData, TVariables>>,\n  options?: MaybeRef<\n    Omit<\n      VueMutationObserverOptions<TData, TError, TVariables, TContext>,\n      'mutationKey' | 'mutationFn'\n    >\n  >,\n): UseMutationReturnType<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  arg1:\n    | MaybeRef<MutationKey>\n    | MaybeRef<MutationFunction<TData, TVariables>>\n    | MaybeRef<VueMutationObserverOptions<TData, TError, TVariables, TContext>>,\n  arg2?:\n    | MaybeRef<MutationFunction<TData, TVariables>>\n    | MaybeRef<VueMutationObserverOptions<TData, TError, TVariables, TContext>>,\n  arg3?: MaybeRef<\n    VueMutationObserverOptions<TData, TError, TVariables, TContext>\n  >,\n): UseMutationReturnType<TData, TError, TVariables, TContext> {\n  if (process.env.NODE_ENV === 'development') {\n    if (!getCurrentScope()) {\n      console.warn(\n        'vue-query composables like \"useQuery()\" should only be used inside a \"setup()\" function or a running effect scope. They might otherwise lead to memory leaks.',\n      )\n    }\n  }\n\n  const options = computed(() => {\n    return parseMutationArgs(arg1, arg2, arg3)\n  })\n  const queryClient =\n    options.value.queryClient ?? useQueryClient(options.value.queryClientKey)\n  const observer = new MutationObserver(\n    queryClient,\n    queryClient.defaultMutationOptions(options.value),\n  )\n  const state = reactive(observer.getCurrentResult())\n\n  const unsubscribe = observer.subscribe((result) => {\n    updateState(state, result)\n  })\n\n  const mutate = (\n    variables: TVariables,\n    mutateOptions?: MutateOptions<TData, TError, TVariables, TContext>,\n  ) => {\n    observer.mutate(variables, mutateOptions).catch(() => {\n      // This is intentional\n    })\n  }\n\n  watch(options, () => {\n    observer.setOptions(queryClient.defaultMutationOptions(options.value))\n  })\n\n  onScopeDispose(() => {\n    unsubscribe()\n  })\n\n  const resultRefs = toRefs(readonly(state)) as unknown as ToRefs<\n    Readonly<MutationResult<TData, TError, TVariables, TContext>>\n  >\n\n  watch(\n    () => state.error,\n    (error) => {\n      if (\n        error &&\n        shouldThrowError(options.value.useErrorBoundary, [error as TError])\n      ) {\n        throw error\n      }\n    },\n  )\n\n  return {\n    ...resultRefs,\n    mutate,\n    mutateAsync: state.mutate,\n    reset: state.reset,\n  }\n}\n\nexport function parseMutationArgs<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  arg1:\n    | MaybeRef<MutationKey>\n    | MaybeRef<MutationFunction<TData, TVariables>>\n    | MaybeRef<VueMutationObserverOptions<TData, TError, TVariables, TContext>>,\n  arg2?:\n    | MaybeRef<MutationFunction<TData, TVariables>>\n    | MaybeRef<VueMutationObserverOptions<TData, TError, TVariables, TContext>>,\n  arg3?: MaybeRef<\n    VueMutationObserverOptions<TData, TError, TVariables, TContext>\n  >,\n): WithQueryClientKey<\n  MutationObserverOptions<TData, TError, TVariables, TContext>\n> {\n  const plainArg1 = unref(arg1)\n  const plainArg2 = unref(arg2)\n  let options = plainArg1\n  if (isMutationKey(plainArg1)) {\n    if (typeof plainArg2 === 'function') {\n      const plainArg3 = unref(arg3)\n      options = { ...plainArg3, mutationKey: plainArg1, mutationFn: plainArg2 }\n    } else {\n      options = { ...plainArg2, mutationKey: plainArg1 }\n    }\n  }\n\n  if (typeof plainArg1 === 'function') {\n    options = { ...plainArg2, mutationFn: plainArg1 }\n  }\n\n  return cloneDeepUnref(options) as UseMutationOptions<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  >\n}\n"],"names":["useMutation","arg1","arg2","arg3","process","env","NODE_ENV","getCurrentScope","console","warn","options","computed","parseMutationArgs","queryClient","value","useQueryClient","queryClientKey","observer","MutationObserver","defaultMutationOptions","state","reactive","getCurrentResult","unsubscribe","subscribe","result","updateState","mutate","variables","mutateOptions","catch","watch","setOptions","onScopeDispose","resultRefs","toRefs","readonly","error","shouldThrowError","useErrorBoundary","mutateAsync","reset","plainArg1","unref","plainArg2","isMutationKey","plainArg3","mutationKey","mutationFn","cloneDeepUnref"],"mappings":"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"}