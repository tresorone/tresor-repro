{"version":3,"file":"useQueries.js","sources":["../../src/useQueries.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { QueriesObserver } from '@tanstack/query-core'\nimport {\n  computed,\n  getCurrentScope,\n  onScopeDispose,\n  reactive,\n  readonly,\n  watch,\n} from 'vue-demi'\nimport { useQueryClient } from './useQueryClient'\nimport { cloneDeepUnref } from './utils'\nimport type { Ref } from 'vue-demi'\n\nimport type { QueryFunction, QueryObserverResult } from '@tanstack/query-core'\n\nimport type { UseQueryOptions } from './useQuery'\nimport type { QueryClient } from './queryClient'\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\ntype GetOptions<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseQueryOptions<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryOptions<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryOptions<unknown, TError, TData>\n    : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n    T extends [infer TQueryFnData, infer TError, infer TData]\n    ? UseQueryOptions<TQueryFnData, TError, TData>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryOptions<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryOptions<TQueryFnData>\n    : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryOptions<TQueryFnData, unknown, TData, TQueryKey>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey> }\n    ? UseQueryOptions<TQueryFnData, unknown, TQueryFnData, TQueryKey>\n    : // Fallback\n      UseQueryOptions\n\ntype GetResults<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? QueryObserverResult<TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? QueryObserverResult<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? QueryObserverResult<TData, TError>\n    : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n    T extends [any, infer TError, infer TData]\n    ? QueryObserverResult<TData, TError>\n    : T extends [infer TQueryFnData, infer TError]\n    ? QueryObserverResult<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? QueryObserverResult<TQueryFnData>\n    : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<unknown, any>\n        select: (data: any) => infer TData\n      }\n    ? QueryObserverResult<TData>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, any> }\n    ? QueryObserverResult<TQueryFnData>\n    : // Fallback\n      QueryObserverResult\n\n/**\n * UseQueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type UseQueriesOptions<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryOptions[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetOptions<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? UseQueriesOptions<[...Tail], [...Result, GetOptions<Head>], [...Depth, 1]>\n  : unknown[] extends T\n  ? T\n  : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n  // use this to infer the param types in the case of Array.map() argument\n  T extends UseQueryOptions<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      infer TQueryKey\n    >[]\n  ? UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>[]\n  : // Fallback\n    UseQueryOptions[]\n\n/**\n * UseQueriesResults reducer recursively maps type param to results\n */\nexport type UseQueriesResults<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? QueryObserverResult[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetResults<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? UseQueriesResults<[...Tail], [...Result, GetResults<Head>], [...Depth, 1]>\n  : T extends UseQueryOptions<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      any\n    >[]\n  ? // Dynamic-size (homogenous) UseQueryOptions array: map directly to array of results\n    QueryObserverResult<unknown extends TData ? TQueryFnData : TData, TError>[]\n  : // Fallback\n    QueryObserverResult[]\n\ntype UseQueriesOptionsArg<T extends any[]> = readonly [...UseQueriesOptions<T>]\n\nexport function useQueries<T extends any[]>({\n  queries,\n  queryClient: queryClientInjected,\n}: {\n  queries: Ref<UseQueriesOptionsArg<T>> | UseQueriesOptionsArg<T>\n  queryClient?: QueryClient\n}): Readonly<UseQueriesResults<T>> {\n  if (process.env.NODE_ENV === 'development') {\n    if (!getCurrentScope()) {\n      console.warn(\n        'vue-query composables like \"useQuery()\" should only be used inside a \"setup()\" function or a running effect scope. They might otherwise lead to memory leaks.',\n      )\n    }\n  }\n\n  const unreffedQueries = computed(() => {\n    const clonedQueries = cloneDeepUnref(queries)\n\n    ;(clonedQueries as any[]).map((query) => {\n      if (typeof query.enabled === 'function') {\n        query.enabled = query.enabled()\n      }\n    })\n\n    return clonedQueries as UseQueriesOptionsArg<T>\n  })\n\n  const queryClientKey = unreffedQueries.value[0]?.queryClientKey\n  const optionsQueryClient = unreffedQueries.value[0]?.queryClient as\n    | QueryClient\n    | undefined\n  const queryClient =\n    queryClientInjected ?? optionsQueryClient ?? useQueryClient(queryClientKey)\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    (queryClientKey || optionsQueryClient)\n  ) {\n    queryClient\n      .getLogger()\n      .error(\n        `Providing queryClient to individual queries in useQueries has been deprecated and will be removed in the next major version. You can still pass queryClient as an option directly to useQueries hook.`,\n      )\n  }\n\n  const defaultedQueries = computed(() =>\n    unreffedQueries.value.map((options) => {\n      const defaulted = queryClient.defaultQueryOptions(options)\n      defaulted._optimisticResults = queryClient.isRestoring.value\n        ? 'isRestoring'\n        : 'optimistic'\n\n      return defaulted\n    }),\n  )\n\n  const observer = new QueriesObserver(queryClient, defaultedQueries.value)\n  const state = reactive(observer.getCurrentResult())\n\n  let unsubscribe = () => {\n    // noop\n  }\n\n  watch(\n    queryClient.isRestoring,\n    (isRestoring) => {\n      if (!isRestoring) {\n        unsubscribe()\n        unsubscribe = observer.subscribe((result) => {\n          state.splice(0, result.length, ...result)\n        })\n        // Subscription would not fire for persisted results\n        state.splice(\n          0,\n          state.length,\n          ...observer.getOptimisticResult(defaultedQueries.value),\n        )\n      }\n    },\n    { immediate: true },\n  )\n\n  watch(\n    defaultedQueries,\n    () => {\n      observer.setQueries(defaultedQueries.value)\n      state.splice(0, state.length, ...observer.getCurrentResult())\n    },\n    { flush: 'sync' },\n  )\n\n  onScopeDispose(() => {\n    unsubscribe()\n  })\n\n  return readonly(state) as UseQueriesResults<T>\n}\n"],"names":["useQueries","queries","queryClient","queryClientInjected","process","env","NODE_ENV","getCurrentScope","console","warn","unreffedQueries","computed","clonedQueries","cloneDeepUnref","map","query","enabled","queryClientKey","value","optionsQueryClient","useQueryClient","getLogger","error","defaultedQueries","options","defaulted","defaultQueryOptions","_optimisticResults","isRestoring","observer","QueriesObserver","state","reactive","getCurrentResult","unsubscribe","watch","subscribe","result","splice","length","getOptimisticResult","immediate","setQueries","flush","onScopeDispose","readonly"],"mappings":";;;;;;;;;AAAA;AAuIO,SAASA,UAAT,CAAqC;EAC1CC,OAD0C;AAE1CC,EAAAA,WAAW,EAAEC,mBAAAA;AAF6B,CAArC,EAM4B;AAAA,EAAA,IAAA,qBAAA,EAAA,sBAAA,EAAA,IAAA,CAAA;;AACjC,EAAA,IAAIC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,aAA7B,EAA4C;IAC1C,IAAI,CAACC,uBAAe,EAApB,EAAwB;MACtBC,OAAO,CAACC,IAAR,CACE,+JADF,CAAA,CAAA;AAGD,KAAA;AACF,GAAA;;AAED,EAAA,MAAMC,eAAe,GAAGC,gBAAQ,CAAC,MAAM;AACrC,IAAA,MAAMC,aAAa,GAAGC,oBAAc,CAACZ,OAAD,CAApC,CAAA;AAEEW,IAAAA,aAAD,CAAyBE,GAAzB,CAA8BC,KAAD,IAAW;AACvC,MAAA,IAAI,OAAOA,KAAK,CAACC,OAAb,KAAyB,UAA7B,EAAyC;AACvCD,QAAAA,KAAK,CAACC,OAAN,GAAgBD,KAAK,CAACC,OAAN,EAAhB,CAAA;AACD,OAAA;KAHF,CAAA,CAAA;AAMD,IAAA,OAAOJ,aAAP,CAAA;AACD,GAV+B,CAAhC,CAAA;EAYA,MAAMK,cAAc,GAAGP,CAAAA,qBAAAA,GAAAA,eAAe,CAACQ,KAAhB,CAAsB,CAAtB,CAAH,KAAG,IAAA,GAAA,KAAA,CAAA,GAAA,qBAAA,CAA0BD,cAAjD,CAAA;EACA,MAAME,kBAAkB,GAAGT,CAAAA,sBAAAA,GAAAA,eAAe,CAACQ,KAAhB,CAAsB,CAAtB,CAAH,KAAG,IAAA,GAAA,KAAA,CAAA,GAAA,sBAAA,CAA0BhB,WAArD,CAAA;EAGA,MAAMA,WAAW,GACfC,CAAAA,IAAAA,GAAAA,mBADe,IACfA,IAAAA,GAAAA,mBADe,GACQgB,kBADR,KAC8BC,IAAAA,GAAAA,IAAAA,GAAAA,6BAAc,CAACH,cAAD,CAD7D,CAAA;;AAEA,EAAA,IACEb,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,KACCW,cAAc,IAAIE,kBADnB,CADF,EAGE;IACAjB,WAAW,CACRmB,SADH,EAAA,CAEGC,KAFH,CAAA,uMAAA,CAAA,CAAA;AAKD,GAAA;;AAED,EAAA,MAAMC,gBAAgB,GAAGZ,gBAAQ,CAAC,MAChCD,eAAe,CAACQ,KAAhB,CAAsBJ,GAAtB,CAA2BU,OAAD,IAAa;AACrC,IAAA,MAAMC,SAAS,GAAGvB,WAAW,CAACwB,mBAAZ,CAAgCF,OAAhC,CAAlB,CAAA;IACAC,SAAS,CAACE,kBAAV,GAA+BzB,WAAW,CAAC0B,WAAZ,CAAwBV,KAAxB,GAC3B,aAD2B,GAE3B,YAFJ,CAAA;AAIA,IAAA,OAAOO,SAAP,CAAA;AACD,GAPD,CAD+B,CAAjC,CAAA;EAWA,MAAMI,QAAQ,GAAG,IAAIC,yBAAJ,CAAoB5B,WAApB,EAAiCqB,gBAAgB,CAACL,KAAlD,CAAjB,CAAA;EACA,MAAMa,KAAK,GAAGC,gBAAQ,CAACH,QAAQ,CAACI,gBAAT,EAAD,CAAtB,CAAA;;EAEA,IAAIC,WAAW,GAAG,MAAM;GAAxB,CAAA;;AAIAC,EAAAA,aAAK,CACHjC,WAAW,CAAC0B,WADT,EAEFA,WAAD,IAAiB;IACf,IAAI,CAACA,WAAL,EAAkB;MAChBM,WAAW,EAAA,CAAA;AACXA,MAAAA,WAAW,GAAGL,QAAQ,CAACO,SAAT,CAAoBC,MAAD,IAAY;QAC3CN,KAAK,CAACO,MAAN,CAAa,CAAb,EAAgBD,MAAM,CAACE,MAAvB,EAA+B,GAAGF,MAAlC,CAAA,CAAA;OADY,CAAd,CAFgB;;AAMhBN,MAAAA,KAAK,CAACO,MAAN,CACE,CADF,EAEEP,KAAK,CAACQ,MAFR,EAGE,GAAGV,QAAQ,CAACW,mBAAT,CAA6BjB,gBAAgB,CAACL,KAA9C,CAHL,CAAA,CAAA;AAKD,KAAA;AACF,GAfE,EAgBH;AAAEuB,IAAAA,SAAS,EAAE,IAAA;AAAb,GAhBG,CAAL,CAAA;EAmBAN,aAAK,CACHZ,gBADG,EAEH,MAAM;AACJM,IAAAA,QAAQ,CAACa,UAAT,CAAoBnB,gBAAgB,CAACL,KAArC,CAAA,CAAA;AACAa,IAAAA,KAAK,CAACO,MAAN,CAAa,CAAb,EAAgBP,KAAK,CAACQ,MAAtB,EAA8B,GAAGV,QAAQ,CAACI,gBAAT,EAAjC,CAAA,CAAA;AACD,GALE,EAMH;AAAEU,IAAAA,KAAK,EAAE,MAAA;AAAT,GANG,CAAL,CAAA;AASAC,EAAAA,sBAAc,CAAC,MAAM;IACnBV,WAAW,EAAA,CAAA;AACZ,GAFa,CAAd,CAAA;EAIA,OAAOW,gBAAQ,CAACd,KAAD,CAAf,CAAA;AACD;;;;"}