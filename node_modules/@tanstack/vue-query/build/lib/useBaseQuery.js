'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var vueDemi = require('vue-demi');
var useQueryClient = require('./useQueryClient.js');
var utils = require('./utils.js');

function useBaseQuery(Observer, arg1, arg2 = {}, arg3 = {}) {
  var _options$value$queryC;

  if (process.env.NODE_ENV === 'development') {
    if (!vueDemi.getCurrentScope()) {
      console.warn('vue-query composables like "useQuery()" should only be used inside a "setup()" function or a running effect scope. They might otherwise lead to memory leaks.');
    }
  }

  const options = vueDemi.computed(() => parseQueryArgs(arg1, arg2, arg3));
  const queryClient = (_options$value$queryC = options.value.queryClient) != null ? _options$value$queryC : useQueryClient.useQueryClient(options.value.queryClientKey);
  const defaultedOptions = vueDemi.computed(() => {
    const defaulted = queryClient.defaultQueryOptions(options.value);
    defaulted._optimisticResults = queryClient.isRestoring.value ? 'isRestoring' : 'optimistic';
    return defaulted;
  });
  const observer = new Observer(queryClient, defaultedOptions.value);
  const state = vueDemi.reactive(observer.getCurrentResult());

  let unsubscribe = () => {// noop
  };

  vueDemi.watch(queryClient.isRestoring, isRestoring => {
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    if (!isRestoring) {
      unsubscribe();
      unsubscribe = observer.subscribe(result => {
        utils.updateState(state, result);
      });
    }
  }, {
    immediate: true
  });

  const updater = () => {
    observer.setOptions(defaultedOptions.value);
    utils.updateState(state, observer.getCurrentResult());
  };

  vueDemi.watch(defaultedOptions, updater);
  vueDemi.onScopeDispose(() => {
    unsubscribe();
  }); // fix #5910

  const refetch = (...args) => {
    updater();
    return state.refetch(...args);
  };

  const suspense = () => {
    return new Promise((resolve, reject) => {
      let stopWatch = () => {//noop
      };

      const run = () => {
        if (defaultedOptions.value.enabled !== false) {
          const optimisticResult = observer.getOptimisticResult(defaultedOptions.value);

          if (optimisticResult.isStale) {
            stopWatch();
            observer.fetchOptimistic(defaultedOptions.value).then(resolve, reject);
          } else {
            stopWatch();
            resolve(optimisticResult);
          }
        }
      };

      run();
      stopWatch = vueDemi.watch(defaultedOptions, run);
    });
  }; // Handle error boundary


  vueDemi.watch(() => state.error, error => {
    if (state.isError && !state.isFetching && utils.shouldThrowError(defaultedOptions.value.useErrorBoundary, [error, observer.getCurrentQuery()])) {
      throw error;
    }
  });
  const object = vueDemi.toRefs(vueDemi.readonly(state));

  for (const key in state) {
    if (typeof state[key] === 'function') {
      object[key] = state[key];
    }
  }

  object.suspense = suspense;
  object.refetch = refetch;
  return object;
}
function parseQueryArgs(arg1, arg2 = {}, arg3 = {}) {
  const plainArg1 = vueDemi.unref(arg1);
  const plainArg2 = vueDemi.unref(arg2);
  const plainArg3 = vueDemi.unref(arg3);
  let options = plainArg1;

  if (!utils.isQueryKey(plainArg1)) {
    options = plainArg1;
  } else if (typeof plainArg2 === 'function') {
    options = { ...plainArg3,
      queryKey: plainArg1,
      queryFn: plainArg2
    };
  } else {
    options = { ...plainArg2,
      queryKey: plainArg1
    };
  }

  const clondedOptions = utils.cloneDeepUnref(options);

  if (typeof clondedOptions.enabled === 'function') {
    clondedOptions.enabled = clondedOptions.enabled();
  }

  return clondedOptions;
}

exports.parseQueryArgs = parseQueryArgs;
exports.useBaseQuery = useBaseQuery;
//# sourceMappingURL=useBaseQuery.js.map
