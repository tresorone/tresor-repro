import { _optionalChain } from '@sentry/utils';
import { HttpInstrumentation } from '@opentelemetry/instrumentation-http';
import { getClient, addOpenTelemetryInstrumentation } from '@sentry/opentelemetry';
import { isSentryRequestUrl, getCapturedScopesOnSpan, getIsolationScope, getCurrentScope, setCapturedScopesOnSpan, defineIntegration, addBreadcrumb } from '@sentry/core';
import { stripUrlQueryAndFragment, parseUrl, getSanitizedUrlString } from '@sentry/utils';
import { setIsolationScope } from '../sdk/scope.js';
import { addOriginToSpan } from '../utils/addOriginToSpan.js';
import { getRequestUrl } from '../utils/getRequestUrl.js';

const INTEGRATION_NAME = 'Http';

let _httpOptions = {};
let _httpInstrumentation;

/**
 * Instrument the HTTP module.
 * This can only be instrumented once! If this called again later, we just update the options.
 */
const instrumentHttp = Object.assign(
  function () {
    if (_httpInstrumentation) {
      return;
    }

    const _InstrumentationClass = _httpOptions._instrumentation || HttpInstrumentation;

    _httpInstrumentation = new _InstrumentationClass({
      ignoreOutgoingRequestHook: request => {
        const url = getRequestUrl(request);

        if (!url) {
          return false;
        }

        if (isSentryRequestUrl(url, getClient())) {
          return true;
        }

        const _ignoreOutgoingRequests = _httpOptions.ignoreOutgoingRequests;
        if (_ignoreOutgoingRequests && _ignoreOutgoingRequests(url)) {
          return true;
        }

        return false;
      },

      ignoreIncomingRequestHook: request => {
        const url = getRequestUrl(request);

        const method = _optionalChain([request, 'access', _ => _.method, 'optionalAccess', _2 => _2.toUpperCase, 'call', _3 => _3()]);
        // We do not capture OPTIONS/HEAD requests as transactions
        if (method === 'OPTIONS' || method === 'HEAD') {
          return true;
        }

        const _ignoreIncomingRequests = _httpOptions.ignoreIncomingRequests;
        if (_ignoreIncomingRequests && _ignoreIncomingRequests(url)) {
          return true;
        }

        return false;
      },

      requireParentforOutgoingSpans: false,
      requireParentforIncomingSpans: false,
      requestHook: (span, req) => {
        addOriginToSpan(span, 'auto.http.otel.http');

        // both, incoming requests and "client" requests made within the app trigger the requestHook
        // we only want to isolate and further annotate incoming requests (IncomingMessage)
        if (_isClientRequest(req)) {
          return;
        }

        const scopes = getCapturedScopesOnSpan(span);

        const isolationScope = (scopes.isolationScope || getIsolationScope()).clone();
        const scope = scopes.scope || getCurrentScope();

        // Update the isolation scope, isolate this request
        isolationScope.setSDKProcessingMetadata({ request: req });

        const client = getClient();
        if (client && client.getOptions().autoSessionTracking) {
          isolationScope.setRequestSession({ status: 'ok' });
        }
        setIsolationScope(isolationScope);
        setCapturedScopesOnSpan(span, scope, isolationScope);

        // attempt to update the scope's `transactionName` based on the request URL
        // Ideally, framework instrumentations coming after the HttpInstrumentation
        // update the transactionName once we get a parameterized route.
        const httpMethod = (req.method || 'GET').toUpperCase();
        const httpTarget = stripUrlQueryAndFragment(req.url || '/');

        const bestEffortTransactionName = `${httpMethod} ${httpTarget}`;

        isolationScope.setTransactionName(bestEffortTransactionName);
      },
      responseHook: () => {
        const client = getClient();
        if (client && client.getOptions().autoSessionTracking) {
          setImmediate(() => {
            client['_captureRequestSession']();
          });
        }
      },
      applyCustomAttributesOnSpan: (
        _span,
        request,
        response,
      ) => {
        const _breadcrumbs = typeof _httpOptions.breadcrumbs === 'undefined' ? true : _httpOptions.breadcrumbs;
        if (_breadcrumbs) {
          _addRequestBreadcrumb(request, response);
        }
      },
    });

    addOpenTelemetryInstrumentation(_httpInstrumentation);
  },
  {
    id: INTEGRATION_NAME,
  },
);

const _httpIntegration = ((options = {}) => {
  return {
    name: INTEGRATION_NAME,
    setupOnce() {
      _httpOptions = options;
      instrumentHttp();
    },
  };
}) ;

/**
 * The http integration instruments Node's internal http and https modules.
 * It creates breadcrumbs and spans for outgoing HTTP requests which will be attached to the currently active span.
 */
const httpIntegration = defineIntegration(_httpIntegration);

/** Add a breadcrumb for outgoing requests. */
function _addRequestBreadcrumb(
  request,
  response,
) {
  // Only generate breadcrumbs for outgoing requests
  if (!_isClientRequest(request)) {
    return;
  }

  const data = getBreadcrumbData(request);
  addBreadcrumb(
    {
      category: 'http',
      data: {
        status_code: response.statusCode,
        ...data,
      },
      type: 'http',
    },
    {
      event: 'response',
      request,
      response,
    },
  );
}

function getBreadcrumbData(request) {
  try {
    // `request.host` does not contain the port, but the host header does
    const host = request.getHeader('host') || request.host;
    const url = new URL(request.path, `${request.protocol}//${host}`);
    const parsedUrl = parseUrl(url.toString());

    const data = {
      url: getSanitizedUrlString(parsedUrl),
      'http.method': request.method || 'GET',
    };

    if (parsedUrl.search) {
      data['http.query'] = parsedUrl.search;
    }
    if (parsedUrl.hash) {
      data['http.fragment'] = parsedUrl.hash;
    }

    return data;
  } catch (e) {
    return {};
  }
}

/**
 * Determines if @param req is a ClientRequest, meaning the request was created within the express app
 * and it's an outgoing request.
 * Checking for properties instead of using `instanceOf` to avoid importing the request classes.
 */
function _isClientRequest(req) {
  return 'outputData' in req && 'outputSize' in req && !('client' in req) && !('statusCode' in req);
}

export { httpIntegration, instrumentHttp };
//# sourceMappingURL=http.js.map
