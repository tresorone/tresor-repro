import { defineIntegration, addBreadcrumb } from '@sentry/core';
import { addOpenTelemetryInstrumentation } from '@sentry/opentelemetry';
import { logger, parseUrl, getSanitizedUrlString } from '@sentry/utils';
import { DEBUG_BUILD } from '../debug-build.js';
import { NODE_MAJOR } from '../nodeVersion.js';
import { addOriginToSpan } from '../utils/addOriginToSpan.js';

const _nativeNodeFetchIntegration = ((options = {}) => {
  const _breadcrumbs = typeof options.breadcrumbs === 'undefined' ? true : options.breadcrumbs;
  const _ignoreOutgoingRequests = options.ignoreOutgoingRequests;

  async function getInstrumentation() {
    // Only add NodeFetch if Node >= 18, as previous versions do not support it
    if (NODE_MAJOR < 18) {
      DEBUG_BUILD && logger.log('NodeFetch is not supported on Node < 18, skipping instrumentation...');
      return;
    }

    try {
      const pkg = await import('opentelemetry-instrumentation-fetch-node');
      const { FetchInstrumentation } = pkg;

      class SentryNodeFetchInstrumentation extends FetchInstrumentation {
        // We extend this method so we have access to request _and_ response for the breadcrumb
         onHeaders({ request, response }) {
          if (_breadcrumbs) {
            _addRequestBreadcrumb(request, response);
          }

          return super.onHeaders({ request, response });
        }
      }

      return new SentryNodeFetchInstrumentation({
        ignoreRequestHook: (request) => {
          const url = request.origin;
          return _ignoreOutgoingRequests && url && _ignoreOutgoingRequests(url);
        },
        onRequest: ({ span }) => {
          _updateSpan(span);
        },
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      } );
    } catch (error) {
      // Could not load instrumentation
      DEBUG_BUILD && logger.log('Could not load NodeFetch instrumentation.');
    }
  }

  return {
    name: 'NodeFetch',
    setupOnce() {
      // eslint-disable-next-line @typescript-eslint/no-floating-promises
      getInstrumentation().then(instrumentation => {
        if (instrumentation) {
          addOpenTelemetryInstrumentation(instrumentation);
        }
      });
    },
  };
}) ;

const nativeNodeFetchIntegration = defineIntegration(_nativeNodeFetchIntegration);

/** Update the span with data we need. */
function _updateSpan(span) {
  addOriginToSpan(span, 'auto.http.otel.node_fetch');
}

/** Add a breadcrumb for outgoing requests. */
function _addRequestBreadcrumb(request, response) {
  const data = getBreadcrumbData(request);

  addBreadcrumb(
    {
      category: 'http',
      data: {
        status_code: response.statusCode,
        ...data,
      },
      type: 'http',
    },
    {
      event: 'response',
      request,
      response,
    },
  );
}

function getBreadcrumbData(request) {
  try {
    const url = new URL(request.path, request.origin);
    const parsedUrl = parseUrl(url.toString());

    const data = {
      url: getSanitizedUrlString(parsedUrl),
      'http.method': request.method || 'GET',
    };

    if (parsedUrl.search) {
      data['http.query'] = parsedUrl.search;
    }
    if (parsedUrl.hash) {
      data['http.fragment'] = parsedUrl.hash;
    }

    return data;
  } catch (e) {
    return {};
  }
}

export { nativeNodeFetchIntegration };
//# sourceMappingURL=node-fetch.js.map
